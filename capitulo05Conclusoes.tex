\chapter{Conclusões}
\label{cap:05}

Este trabalho abordou um estudo analítico entre tecnologias diferentes, mas que servem a um mesmo propósito, e um estudo de usabilidade sobre a linguagem de programação \textit{Kotlin}, referente à todo o ecossistema que envolve a plataforma \textit{Android}.

Adicionalmente, foram apresentados, em caráter introdutório, as principais tecnologias que fazem parte do desenvolvimento voltado para os dispositivos móveis, desde os meios para a elaboração de aplicações tanto nativas e específicas para apenas uma plataforma, como aplicações que atingem ambos os públicos com tecnologias denominadas híbridas/multiplataforma. Também foram apresentados os conceitos de qualidade de código por meio de ferramentas e da reescrita, e detalharam-se alguns trabalhos com segmento semelhante ao contexto deste trabalho.

Baseando-se em três índices qualificadores de código, sendo eles, a quantidade de caracteres, as linhas de código utilizadas e o tamanho do arquivo em \textit{bytes}, foram implementados 07 experimentos práticos, desde alguns algoritmos mais simples como operação matemática, \textit{Hello World} e classe \textit{model}, finalizando com uma aplicação móvel \textit{Android} que realiza a conversão de medidas termométricas de Celsius para Fahrenheit e/ou Kelvin, por meio da interação com o usuário, baseada um padrão de projeto. De acordo com os códigos desempenhados foi realizada a comparação entre a linguagem \textit{Kotlin} e \textit{Java}, no qual, \textit{Kotlin} mostrou-se, tão eficaz quanto Java, chegando ao mesmo resultado, com menor necessidade de caracteres, linhas de código e da mesma forma tamanho final em \textit{bytes}, sendo superior em todos os experimentos implementados.

Somando-se todos os trechos de código demonstrados nos experimentos, em \textit{Java} foram necessários: \textbf{6.320} caracteres, \textbf{218} linhas de código e \textbf{6.938} bytes. Por outro lado, com \textit{Kotlin}, obteve-se os mesmos resultados finais, por meio de: \textbf{3.718} caracteres, \textbf{119} linhas de código e \textbf{4.480} bytes.
%\begin{itemize}
    %\\item \textbf{6.320} caracteres;
    %\\item\textbf{218} linhas de código;
    %\\item  \textbf{6.938} bytes.
%\\end{itemize}

 %\Toda via, com o \textit{Kotlin}, obteve-se os mesmos %\resultados finais, por meio de:
%\ \begin{itemize}
 %\\item  \textbf{3.718} caracteres;
 %\ \item \textbf{119} linhas de código;
 %\ \item \textbf{4.480} bytes.
 %\\end{itemize}
Foram apresentados os pontos negativos e positivos na adoção da tecnologia \textit{Kotlin} como linguagem de programação, onde destacou-se como negativo o aumento no tempo de execução de projetos \textit{Kotlin} e como positivo, a sua fácil adaptação para programadores com conhecimento prévio.

Para trabalhos futuros, o conceito da diminuição de utilização de códigos desnecessários no desenvolvimento de \textit{software} apresentados neste trabalho pode motivar novas pesquisas relacionadas, como a comparação de tecnologias que propõe-se a entregar aplicações móveis multiplataforma e nativas, ou seja, para \textit{Android} e \textit{iOS}. As tecnologias e linguagens adotadas e desenvolvidas por grandes empresas que são referência no meio tecnológico, como a ferramenta \textit{Flutter} que utiliza a linguagem \textit{Dart} ambos projetos criados pela \textit{Google} e o \textit{framework} \textit{React Native} criado pelo \textit{Facebook} que utiliza \textit{JavaScript} são exemplos de alternativas emergentes no momento em que esse trabalho foi realizado. Outra opção de futuros projetos relacionados a este trabalho de conclusão de curso seria uma nova comparação entre as linguagens \textit{Java} e \textit{Kotlin}, mas com foco em \textit{CRUD's}\footnote[1]{Acrônimo em inglês para operações básicas de um sistema, sendo elas: C de  \textit{create} (inclusão), R de  \textit{read} (leitura), U de  \textit{update} (atualização) e D de  \textit{delete} (remoção) \cite{CRUD}}, desenvolvimento da Sequência de \textit{Fibonacci},  operações matemáticas e cálculos mais elaborados e de algoritmos de encriptação para se medir a complexidade em cada uma das abordagens.




